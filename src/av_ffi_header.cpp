const char * av_ffi_header = ""
"-- generated from av.h on Thu Jun 27 18:55:47 2013 \n"
"print('Built on Thu Jun 27 18:55:47 2013') \n"
"local header = [[ \n"
" void av_sleep(double seconds); \n"
" double av_time(); \n"
" double av_filetime(const char * filename); \n"
"enum { \n"
" AV_KEY_ENTER =3, \n"
" AV_KEY_BACKSPACE =8, \n"
" AV_KEY_TAB =9, \n"
" AV_KEY_RETURN =13, \n"
" AV_KEY_ESCAPE =27, \n"
" AV_KEY_DELETE =127, \n"
" AV_KEY_F1=256, \n"
" AV_KEY_F2, AV_KEY_F3, AV_KEY_F4, AV_KEY_F5, AV_KEY_F6, AV_KEY_F7, AV_KEY_F8, AV_KEY_F9, AV_KEY_F10, AV_KEY_F11, AV_KEY_F12, \n"
" AV_KEY_INSERT, \n"
" AV_KEY_LEFT, AV_KEY_UP, AV_KEY_RIGHT, AV_KEY_DOWN, \n"
" AV_KEY_PAGE_DOWN, AV_KEY_PAGE_UP, \n"
" AV_KEY_END, AV_KEY_HOME \n"
"}; \n"
"typedef struct av_Window { \n"
" int width, height; \n"
" int is_fullscreen; \n"
" int button; \n"
" int shift, alt, ctrl; \n"
" int is_stereo; \n"
" double fps; \n"
" void (*oncreate)(struct av_Window * self); \n"
" void (*onresize)(struct av_Window * self, int w, int h); \n"
" void (*onvisible)(struct av_Window * self, int state); \n"
" void (*ondraw)(struct av_Window * self); \n"
" void (*onkey)(struct av_Window * self, int event, int key); \n"
" void (*onmouse)(struct av_Window * self, int event, int button, int x, int y); \n"
"} av_Window; \n"
"enum { \n"
" AV_AUDIO_CMD_EMPTY, \n"
" AV_AUDIO_CMD_GENERIC = 128, \n"
" AV_AUDIO_CMD_CLEAR, \n"
" AV_AUDIO_CMD_VOICE_ADD, \n"
" AV_AUDIO_CMD_VOICE_REMOVE, \n"
" AV_AUDIO_CMD_VOICE_PARAM, \n"
" AV_AUDIO_CMD_VOICE_CODE, \n"
" AV_AUDIO_CMD_SKIP = 255 \n"
"}; \n"
"typedef struct av_msg_param { \n"
" int id, pid; \n"
" double value; \n"
"} av_msg_param; \n"
"typedef struct av_msgbuffer { \n"
" int read, write, size, unused; \n"
" unsigned char * data; \n"
"} av_msgbuffer; \n"
"typedef struct av_Audio { \n"
" unsigned int blocksize; \n"
" unsigned int frames; \n"
" unsigned int indevice, outdevice; \n"
" unsigned int inchannels, outchannels; \n"
" double time; \n"
" double samplerate; \n"
" double lag; \n"
" av_msgbuffer msgbuffer; \n"
" float * buffer; \n"
" int blocks, blockread, blockwrite, blockstep; \n"
" float * input; \n"
" float * output; \n"
" void (*onframes)(struct av_Audio * self, double sampletime, float * inputs, float * outputs, int frames); \n"
"} av_Audio; \n"
" av_Window * av_window_create(); \n"
" void av_window_setfullscreen(av_Window * self, int b); \n"
" void av_window_settitle(av_Window * self, const char * name); \n"
" void av_window_setdim(av_Window * self, int x, int y); \n"
" void av_state_reset(void * state); \n"
" av_Audio * av_audio_get(); \n"
" void av_audio_start(); \n"
"typedef struct { \n"
" int kind; \n"
" int xdata; \n"
" void *data[3]; \n"
"} CXCursor; \n"
"typedef struct av_clang_visitor { \n"
" int (*fun)(CXCursor *cursor, CXCursor *parent); \n"
"} av_clang_visitor; \n"
" int av_clang_visit(CXCursor cursor, CXCursor parent, void * ud); \n"
"typedef struct lua_State lua_State; \n"
" int luaopen_lpeg (lua_State *L); \n"
" int luaopen_http_parser(lua_State* L); \n"
"]] \n"
"local ffi = require 'ffi' \n"
"ffi.cdef(header) \n"
"return header \n";
const char * av_main = ""
"-- main.lua \n"
" \n"
"local exepath = select(1, ...) or \".\" \n"
"local filename = select(2, ...) or \"start.lua\" \n"
"local args = { select(3, ...) } \n"
" \n"
"local startupscript = [[ \n"
"	local exepath, builtin_header = ... \n"
"	_G.exepath = exepath \n"
"	 \n"
"	-- also search in /modules for Lua modules: \n"
"	package.path = string.format('%s/modules/?.lua;%s/modules/?/init.lua;%s', exepath, exepath, package.path);  \n"
" \n"
"	-- define the AV header in FFI: \n"
"	local ffi = require 'ffi' \n"
" \n"
"	package.loaded.builtin = builtin_header \n"
"	ffi.cdef(builtin_header) \n"
"	 \n"
"	print(\"initialize window\") \n"
"	-- initialize the window bindings: \n"
"	win = require \"window\"	 \n"
"]] \n"
" \n"
"-- load the modules we need: \n"
"local ffi = require \"ffi\" \n"
"local C = ffi.C \n"
"local builtin = require \"builtin\" \n"
" \n"
"-- also search in /modules for Lua modules: \n"
"package.path = string.format('%s/modules/?.lua;%s/modules/?/init.lua;%s', exepath, exepath, package.path);  \n"
"local lua = require \"lua\" \n"
" \n"
"-- a bit of helpful info: \n"
"print(string.format(\"Using %s on %s (%s)\", jit.version, jit.os, jit.arch)) \n"
" \n"
"local watched = {} \n"
"local states = {} \n"
" \n"
"function av_tick() \n"
"	-- filewatch: \n"
"	for filename, mtime in pairs(watched) do \n"
"		local t = C.av_filetime(filename) \n"
"		if t > mtime then \n"
"			watched[filename] = t \n"
"			spawn(filename) \n"
"		end \n"
"	end \n"
"end \n"
" \n"
"-- basic file spawning.  \n"
"-- this will allow us to scale up to filewatching and multiple states in the future \n"
" \n"
"function spawn(filename) \n"
"	if states[filename] then		 \n"
"		cancel(states[filename]) \n"
"	end \n"
"	 \n"
"	print(string.rep(\"-\", 80)) \n"
"	-- create a child Lua state to run user code in: \n"
"	L = lua.open() \n"
"	L:openlibs() \n"
"	 \n"
"	-- preload lpeg: \n"
"	L:getglobal(\"package\") \n"
"	L:getfield(-1, \"preload\") \n"
"	L:pushcfunction(C.luaopen_lpeg) \n"
"	L:setfield(-2, \"lpeg\") \n"
"	L:pushcfunction(C.luaopen_http_parser) \n"
"	L:setfield(-2, \"http.parser\") \n"
"	L:settop(0) \n"
"	 \n"
"	states[filename] = L \n"
"	 \n"
"	-- 'prime' this state with the module search path and built-in FFI header: \n"
"	L:dostring(startupscript, exepath, builtin.header) \n"
"	 \n"
"	print(string.format(\"running %s at %s\", filename, os.date())) \n"
"	print(string.rep(\"-\", 80)) \n"
" \n"
"	L:dofile(filename, unpack(args)) \n"
"	 \n"
"	return L \n"
"end \n"
" \n"
"function cancel(L) \n"
"	if L then \n"
"		print('canceling', filename) \n"
"		 \n"
"		-- trigger handler: \n"
"		L:getglobal(\"close\") \n"
"		if L:isfunction(-1) then \n"
"			if L:call(0, 0) then \n"
"				print(\"error on close\", L:tostring(-1)) \n"
"			end \n"
"		else \n"
"			L:pop(1) \n"
"		end \n"
"		 \n"
"		-- before calling L:close(), we need to unregister any application callbacks! \n"
"		C.av_state_reset(L) \n"
"		-- should be safe to shutdown now: \n"
"		L:close() \n"
"		print(string.rep(\"-\", 80)) \n"
"	end \n"
"end \n"
" \n"
"function watch(filename) \n"
"	watched[filename] = 0 \n"
"end \n"
" \n"
"watch(filename) \n"
" \n";