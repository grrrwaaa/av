<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>ldoc</h1>

<ul>
  <li><a href="../reference.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#Functions">Functions</a></li>
</ul>


<h2>Modules</h2>
<ul>
  <li><a href="../modules/allosphere.html">allosphere</a></li>
  <li><a href="../modules/audio.html">audio</a></li>
  <li><a href="../modules/audioprocess.html">audioprocess</a></li>
  <li><a href="../modules/displaylist.html">displaylist</a></li>
  <li><a href="../modules/draw2D.html">draw2D</a></li>
  <li><a href="../modules/draw3D.html">draw3D</a></li>
  <li><strong>field2D</strong></li>
  <li><a href="../modules/field3D.html">field3D</a></li>
  <li><a href="../modules/io.html">io</a></li>
  <li><a href="../modules/mat4.html">mat4</a></li>
  <li><a href="../modules/math.html">math</a></li>
  <li><a href="../modules/nav3.html">nav3</a></li>
  <li><a href="../modules/os.html">os</a></li>
  <li><a href="../modules/quat.html">quat</a></li>
  <li><a href="../modules/string.html">string</a></li>
  <li><a href="../modules/table.html">table</a></li>
  <li><a href="../modules/util.html">util</a></li>
  <li><a href="../modules/vec2.html">vec2</a></li>
  <li><a href="../modules/vec3.html">vec3</a></li>
  <li><a href="../modules/vec4.html">vec4</a></li>
</ul>

</div>

<div id="content">

<h1>Module <code>field2D</code></h1>

<p>Field2D: an object representing a 2D densely packed array.</p>
<p></p>


<h2><a href="#Functions">Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#field2D:set">field2D:set&nbsp;(value, x, y)</a></td>
	<td class="summary">set the value of a cell, or of all cells.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#field2D:get">field2D:get&nbsp;(x, y)</a></td>
	<td class="summary">return the value of a cell
 If x or y is out of range of the field, it wraps around (positive modulo)
 If x or y are not integers, the fractional component is discarded (rounded down)</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#field2D:sample">field2D:sample&nbsp;(x, y)</a></td>
	<td class="summary">return the value at a normalized index (0..1 range maps to field dimensions)
 Uses linear interpolation between nearest cells.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#field2D:update">field2D:update&nbsp;(value, x, y)</a></td>
	<td class="summary">Update the field at a normalized (0..1) index
 Like field2D:set(), but uses linear interpolation to distribute the update between nearest cells (thus it is an inverse of field:sample()).</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#field2D:splat">field2D:splat&nbsp;(value, x, y)</a></td>
	<td class="summary">Add a value to the field at a normalized (0..1) index
 Uses linear interpolation to distribute the value between nearest cells, for accumulation.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#field2D:scale">field2D:scale&nbsp;(value, x, y)</a></td>
	<td class="summary">Multiply the field by a value, optionally at a normalized (0..1) index
 If indices are not given, all cells are multipled by the value.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#field2D:diffuse">field2D:diffuse&nbsp;(sourcefield, diffusion, passes)</a></td>
	<td class="summary">fill the field with a diffused (blurred) copy of another</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#field2D:map">field2D:map&nbsp;(func)</a></td>
	<td class="summary">Apply a function to each cell of the field in turn
 The function arguments will be the current value of the cell and the x and y position, and the return value should be the new value of the cell (or nil to indicate no change).</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#field2D:normalize">field2D:normalize&nbsp;()</a></td>
	<td class="summary">normalize the field values to a 0..1 range</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#field2D:sum">field2D:sum&nbsp;()</a></td>
	<td class="summary">return the sum of all cells</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#field2D:max">field2D:max&nbsp;()</a></td>
	<td class="summary">return the maximum value of all cells</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#field2D:min">field2D:min&nbsp;()</a></td>
	<td class="summary">return the minimum value of all cells</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#field2D:draw">field2D:draw&nbsp;(x, y, w, h, unit)</a></td>
	<td class="summary">Draw the field in greyscale from 0..1</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#field2D:drawHueRange">field2D:drawHueRange&nbsp;(range)</a></td>
	<td class="summary">Draw the field as a Hue spectrum from red to blue</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#drawFlow">drawFlow&nbsp;(fx, fy)</a></td>
	<td class="summary">draw two fields representing X and Y vector components</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#field2D:copy">field2D:copy&nbsp;()</a></td>
	<td class="summary">Create a copy of the field with the same dimensions and contents</td>
	</tr>
</table>

<br/>
<br/>


    <h2><a name="Functions"></a>Functions</h2>
    <dl class="function">
    <dt>
    <a name = "field2D:set"></a>
    <strong>field2D:set&nbsp;(value, x, y)</strong>
    </dt>
    <dd>
    set the value of a cell, or of all cells.
 If the x,y coordinate is not specified, it will apply the value for all cells.
 If the value to set is a function, this function is called (passing the x, y coordinates as arguments). If the function returns a value, the cell is set to this value; otherwise the cell is left unchanged.

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">value</span>
        <span class="types"><span class="type">number</span> or <span class="type">function</span></span>
       to set</li>
      <li><span class="parameter">x</span>
        <span class="types">optional <span class="type">int</span></span>
       coordinate (row) to set a single cell</li>
      <li><span class="parameter">y</span>
        <span class="types">optional <span class="type">int</span></span>
       coordinate (column) to set a single cell</li>
    </ul>





</dd>
    <dt>
    <a name = "field2D:get"></a>
    <strong>field2D:get&nbsp;(x, y)</strong>
    </dt>
    <dd>
    return the value of a cell
 If x or y is out of range of the field, it wraps around (positive modulo)
 If x or y are not integers, the fractional component is discarded (rounded down)

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">x</span>
        <span class="types">optional <span class="type">int</span></span>
       coordinate (row) to get a single cell</li>
      <li><span class="parameter">y</span>
        <span class="types">optional <span class="type">int</span></span>
       coordinate (column) to get a single cell</li>
    </ul>





</dd>
    <dt>
    <a name = "field2D:sample"></a>
    <strong>field2D:sample&nbsp;(x, y)</strong>
    </dt>
    <dd>
    return the value at a normalized index (0..1 range maps to field dimensions)
 Uses linear interpolation between nearest cells.
 Indices out of range will wrap.

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">x</span>
       coordinate (0..1) to sample</li>
      <li><span class="parameter">y</span>
       coordinate (0..1) to sample</li>
    </ul>





</dd>
    <dt>
    <a name = "field2D:update"></a>
    <strong>field2D:update&nbsp;(value, x, y)</strong>
    </dt>
    <dd>
    Update the field at a normalized (0..1) index
 Like field2D:set(), but uses linear interpolation to distribute the update between nearest cells (thus it is an inverse of field:sample()).  If the index falls exactly in the center of one cell, it is equivalent to field:set(). Otherwise, the four nearest cells will be updated as a weighted average of their current and the new value.
 If the value is a function, this function is called for each nearby cell to generate a new value. The function argument is the old value of the cell.
 Indices out of range will wrap.

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">value</span>
       (number or function) the value to update the field</li>
      <li><span class="parameter">x</span>
       coordinate (0..1) to update</li>
      <li><span class="parameter">y</span>
       coordinate (0..1) to update</li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        self
    </ol>




</dd>
    <dt>
    <a name = "field2D:splat"></a>
    <strong>field2D:splat&nbsp;(value, x, y)</strong>
    </dt>
    <dd>
    Add a value to the field at a normalized (0..1) index
 Uses linear interpolation to distribute the value between nearest cells, for accumulation.
 Indices out of range will wrap.

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">value</span>
       the value to add to the field</li>
      <li><span class="parameter">x</span>
       coordinate (0..1) to update</li>
      <li><span class="parameter">y</span>
       coordinate (0..1) to update</li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        self
    </ol>




</dd>
    <dt>
    <a name = "field2D:scale"></a>
    <strong>field2D:scale&nbsp;(value, x, y)</strong>
    </dt>
    <dd>
    Multiply the field by a value, optionally at a normalized (0..1) index
 If indices are not given, all cells are multipled by the value.
 Otherwise, uses linear interpolation to distribute the value between nearest cells, for multiplication. If the position index is exactly in the center of a cell, it performs a normal multiplcation. Otherwise the four nearest cells are updated according to a weighted average of their current and modified value.
 Indices out of range will wrap.

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">value</span>
       the value to scale to the field</li>
      <li><span class="parameter">x</span>
       coordinate (0..1) to update (optional)</li>
      <li><span class="parameter">y</span>
       coordinate (0..1) to update (optional)</li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        self
    </ol>




</dd>
    <dt>
    <a name = "field2D:diffuse"></a>
    <strong>field2D:diffuse&nbsp;(sourcefield, diffusion, passes)</strong>
    </dt>
    <dd>
    fill the field with a diffused (blurred) copy of another

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">sourcefield</span>
       the field to be diffused</li>
      <li><span class="parameter">diffusion</span>
       the rate of diffusion</li>
      <li><span class="parameter">passes</span>
       ?int the number of iterations to improve numerical accuracy (default 10)</li>
    </ul>





</dd>
    <dt>
    <a name = "field2D:map"></a>
    <strong>field2D:map&nbsp;(func)</strong>
    </dt>
    <dd>
    Apply a function to each cell of the field in turn
 The function arguments will be the current value of the cell and the x and y position, and the return value should be the new value of the cell (or nil to indicate no change).  E.g. to multiply all cells by 2: field:map(function(value, x, y) return value * 2 end)

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">func</span>
       the function to apply</li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        self
    </ol>




</dd>
    <dt>
    <a name = "field2D:normalize"></a>
    <strong>field2D:normalize&nbsp;()</strong>
    </dt>
    <dd>
    normalize the field values to a 0..1 range


    <h3>Returns:</h3>
    <ol>

        self
    </ol>




</dd>
    <dt>
    <a name = "field2D:sum"></a>
    <strong>field2D:sum&nbsp;()</strong>
    </dt>
    <dd>
    return the sum of all cells


    <h3>Returns:</h3>
    <ol>

        sum
    </ol>




</dd>
    <dt>
    <a name = "field2D:max"></a>
    <strong>field2D:max&nbsp;()</strong>
    </dt>
    <dd>
    return the maximum value of all cells


    <h3>Returns:</h3>
    <ol>

        max
    </ol>




</dd>
    <dt>
    <a name = "field2D:min"></a>
    <strong>field2D:min&nbsp;()</strong>
    </dt>
    <dd>
    return the minimum value of all cells


    <h3>Returns:</h3>
    <ol>

        min
    </ol>




</dd>
    <dt>
    <a name = "field2D:draw"></a>
    <strong>field2D:draw&nbsp;(x, y, w, h, unit)</strong>
    </dt>
    <dd>
    Draw the field in greyscale from 0..1

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">x</span>
       left coordinate (optional, defaults to 0)</li>
      <li><span class="parameter">y</span>
       bottom coordinate (optional, defaults to 0)</li>
      <li><span class="parameter">w</span>
       width (optional, defaults to 1)</li>
      <li><span class="parameter">h</span>
       height (optional, defaults to 1)</li>
      <li><span class="parameter">unit</span>
       texture unit to use (defaults to 0)</li>
    </ul>





</dd>
    <dt>
    <a name = "field2D:drawHueRange"></a>
    <strong>field2D:drawHueRange&nbsp;(range)</strong>
    </dt>
    <dd>
    Draw the field as a Hue spectrum from red to blue

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">range</span>
       the maximum field value (renders as blue)</li>
    </ul>





</dd>
    <dt>
    <a name = "drawFlow"></a>
    <strong>drawFlow&nbsp;(fx, fy)</strong>
    </dt>
    <dd>
    draw two fields representing X and Y vector components

    <h3>Parameters:</h3>
    <ul>
      <li><span class="parameter">fx</span>
       X component field</li>
      <li><span class="parameter">fy</span>
       Y component field</li>
    </ul>





</dd>
    <dt>
    <a name = "field2D:copy"></a>
    <strong>field2D:copy&nbsp;()</strong>
    </dt>
    <dd>
    Create a copy of the field with the same dimensions and contents






</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.3</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
